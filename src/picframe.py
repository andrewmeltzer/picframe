#!/mnt/c/tmp/frame/env/bin/python3

import getopt
import sys
import os
import logging
import time
import multiprocessing as mp

from picframe_settings import PFSettings
from picframe_env import PFEnv
from picframe_image import PFImage
from picframe_timer import PFTimer
from picframe_blackout import PFBlackout
from picframe_message import PFMessageContent
from picframe_state import PFState, PFStates

# TODO: ++++
# - Need a way to kill it when it is sleeping.
# - Want to support gif,tif and videos (mp4, mov, wmv, mp3, wav).  
# - Change it so that there are no sleep statements:
#   - The image displayer is event driven, waiting for an event to be posted
#   - The events are generated by:
#       - A timer module doing the image wait time and sleep interval
#       - A keyboard module that takes commands like
#           - n: next
#           - h: hold
#           - S: Start sleep as if the sleep event went off
#           - s: Stop sleep as if the sleep is done event went off
#           - M: Motion start as if the motion detector went toff
#           - m: Motion stop as if the motion detector timed out
#           - Vn: As if the video brightness went up
#           - vn: As if the video brightness went down
#           - x or q: Quit

############################################################
# print_help
#
def print_help(rval=0):
    """
    Print out the command-line help.
    """

    print("picframe.py ")
    print("    <-h|--help>")
    print("    <-s|--single=<path to single image>")
    print("    <-p|--path=<path to image root directory>")
    print("    <-d|--debug=<debug level (DEBUG, INFO, WARN, ERROR)")
    print("    <-l|--logfile=<path to log file>")
    print("    <-f|--fullscreen")
    print("    <-g|--geom=<a geometry in the form 1920x1080)>")
    sys.exit(rval)

############################################################
# get_args
#
def get_args(argv):
    """
    Get input arguments

    Inputs:
    argv: the input arguments to the program.
    Returns: None
        sets global settings and environmentt settings
    """

    # Start with the geometry from the settings
    if PFSettings.geometry_str != None:
        PFSettings.fullscreen = False
        PFEnv.geometry_str = PFSettings.geometry_str
        wstr, hstr = PFSettings.geometry_str.split('x')
        PFEnv.screen_height = int(hstr)
        PFEnv.screen_width = int(wstr)
        PFEnv.geometry = (PFEnv.screen_width, PFEnv.screen_height)

    try:
        opts, inargs = getopt.getopt(argv, "hfs:d:g:",
                ["help", "fullscreen", "logfile=", "debuglevel=", "single=", "path=", "geom="])
    except getopt.GetoptError:
        print_help()
        sys.exit(2)

    for opt, arg in opts:
        if opt in ('-h', '--help'):
            print_help()
        elif opt in ('-d', '--debuglevel'):
            PFSettings.debug_level = arg.upper()
        elif opt in ('-l', '--logfile'):
            PFSettings.logfile = arg
        elif opt in ('-f', '--fullscreen'):
            PFSettings.fullscreen = True
        elif opt in ('-g', '--geom'):
            PFSettings.fullscreen = False
            PFEnv.geometry_str = arg
            wstr, hstr = arg.split('x')
            PFEnv.screen_height = int(hstr)
            PFEnv.screen_width = int(wstr)
            PFEnv.geometry = (PFEnv.screen_width, PFEnv.screen_height)
        elif opt in ('-s', '--single'):
            PFSettings.single_image = True
            PFSettings.image_dir = arg
        elif opt in ('-p', '--path'):
            PFSettings.single_image = False
            PFSettings.image_dir = arg

############################################################
#
# setup_logger
#
def setup_logger():
    """
    Setup the logger for the application.
    Args:
    Returns:
        none
    """
    if not PFEnv.logger_initialized:
        logfile = None
        logger_handler = None

        # If the user wants the logfile to go to the default file location
        # with a datestamp
        if PFSettings.log_to_stdout == False:
            # If want it in utc
            #timestamp = datetime.now(timezone.utc).strftime(PFEnv.MS_FMT_STR)
            timestamp = datetime.now().strftime(PFEnv.MS_FMT_STR)
            fname = "picframe_" + timestamp + ".log"
            path = PFSettings.log_directory

            if not os.path.exists(path):
                os.makedirs(path)
            logfile = os.path.join(path, fname)

            logger_handler = logging.FileHandler(logfile)
        else:
            logger_handler = logging.StreamHandler(sys.stdout)

        log_formatter = logging.Formatter('{"time": "%(asctime)s", "level": "%(levelname)s", "info": %(message)s}')
        log_formatter.converter = time.gmtime
        logger_root = logging.getLogger()
        logger_root.setLevel(PFSettings.debug_level)

        logger_handler.setLevel(PFSettings.debug_level)
        logger_root.addHandler(logger_handler)
        logger_handler.setFormatter(log_formatter)

        PFEnv.logger_initialized = True

############################################################
#
# process_message
#
def process_message(message):
    """
    Process the next message from the queue based on the current state
    of the system and the message.  As a rule of thumb, keyboard actions
    take precedence over everything else.
    """

    # Only go to the next message if in the normal state.
    if message.message == PFMessageContent.TIMER_NEXT_IMAGE:
        if PFState.current_state == PFStates.NORMAL:
            PFImage.display_next_image()

    # If the keyboard says next image, override any holds or blackouts
    elif message.message == PFMessageContent.KEYBOARD_NEXT_IMAGE:
        PFImage.display_next_image()

    elif message.message == PFMessageContent.KEYBOARD_HOLD:
        pass
    elif message.message == PFMessageContent.KEYBOARD_END_HOLD:
        PFImage.display_next_image()
    elif message.message == PFMessageContent.KEYBOARD_BLACKOUT:
        PFImage.display_black_image()
    elif message.message == PFMessageContent.KEYBOARD_END_BLACKOUT:
        PFImage.display_next_image()
    elif message.message == PFMessageContent.KEYBOARD_INCREASE_BRIGHTNESS:
        PFState.keyboard_brightness = True
    elif message.message == PFMessageContent.KEYBOARD_DECREASE_BRIGHTNESS:
        PFState.keyboard_brightness = True
    elif message.message == PFMessageContent.KEYBOARD_USE_DEFAULT_BRIGHTNESS:
        PFState.keyboard_brightness = False
    elif message.message == PFMessageContent.KEYBOARD_EMULATE_MOTION:
        PFImage.display_next_image()
    elif message.message == PFMessageContent.KEYBOARD_EMULATE_MOTION_TIMEOUT:
        PFImage.display_black_image()
    elif message.message == PFMessageContent.BLACKOUT:
        PFImage.display_black_image()
    elif message.message == PFMessageContent.END_BLACKOUT:
        pass
    elif message.message == PFMessageContent.INCREASE_BRIGHTNESS:
        pass
    elif message.message == PFMessageContent.DECREASE_BRIGHTNESS:
        pass
    elif message.message == PFMessageContent.MOTION:
        pass
    elif message.message == PFMessageContent.MOTION_TIMEOUT:
        PFImage.display_black_image()

    PFState.new_state(message)


############################################################
#
# main
#
def main():
    """
    """

    queue = mp.Queue()
    timer_p = mp.Process(target=PFTimer.timer_main, args=(queue,))
    blackout_p = mp.Process(target=PFBlackout.blackout_main, args=(queue,))
    timer_p.start()
    blackout_p.start()

    while True:
        message = queue.get()
        process_message(message)


if __name__ == "__main__":
    PFEnv.init_environment()
    get_args(sys.argv[1:])
    setup_logger()
    main()

    sys.exit(0)
